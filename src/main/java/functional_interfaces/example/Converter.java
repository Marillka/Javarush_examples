package functional_interfaces.example;

import java.util.Comparator;

/*
Если в интерфейсе с данной аннотацие более одного не реализованного (абстрвактного) метода, компилятор не пропустит данный интерфейс.


Теперь вопрос: а зачем же нам ограничение одним не реализованным методом в функциональном интерфейсе?

А затем, чтобы мы могли его реализовать с помощью лямбд.
 */
@FunctionalInterface
public interface Converter<T, N> {
    N convert(T t);

    // Статические методы привязаны непостредственно к классу, и для вызова такого метода не нужен конкретный объект данного класса.
    static <T> boolean isNotNull(T t) {
        return t != null;
    }

    default void writeToConsole(T t) {
        System.out.println("Текущий объект - " + t.toString());
    }

    // все классы наследуются от класса Object.
    // Это не касается интерфейсов. Но если у нас в интерфейсе будет абстрактный метод, совпадающий сигнатурой с каким-то методом класса Object, такой метод (или методы) не поломает наше ограничение функционального интерфейса:

    boolean equals(Object obj);




}
